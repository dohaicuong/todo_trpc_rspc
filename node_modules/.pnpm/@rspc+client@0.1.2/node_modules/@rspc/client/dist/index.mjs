// src/transport.ts
var FetchTransport = class {
  constructor(url) {
    this.url = url;
  }
  async doRequest(operation, key, input) {
    if (operation === "subscription" || operation === "subscriptionStop") {
      throw new Error(
        `Subscribing to '${key}' failed as the HTTP transport does not support subscriptions! Maybe try using the websocket transport?`
      );
    }
    let method = "GET";
    let body = void 0;
    let headers = new Headers();
    const params = new URLSearchParams();
    if (operation === "query") {
      if (input !== void 0) {
        params.append("input", JSON.stringify(input));
      }
    } else if (operation === "mutation") {
      method = "POST";
      body = JSON.stringify(input || {});
      headers.set("Content-Type", "application/json");
    }
    const paramsStr = params.toString();
    const resp = await fetch(
      `${this.url}/${key}${paramsStr.length > 0 ? `?${paramsStr}` : ""}`,
      {
        method,
        body,
        headers
      }
    );
    const respBody = await resp.json();
    const { type, data } = respBody.result;
    if (type === "error") {
      const { code, message } = data;
      throw new RSPCError(code, message);
    }
    return data;
  }
};
var randomId = () => Math.random().toString(36).slice(2);
var timeouts = [1e3, 2e3, 5e3, 1e4];
var WebsocketTransport = class {
  constructor(url) {
    this.requestMap = /* @__PURE__ */ new Map();
    this.url = url;
    this.ws = new WebSocket(url);
    this.attachEventListeners();
  }
  attachEventListeners() {
    this.ws.addEventListener("message", (event) => {
      var _a, _b;
      const { id, result } = JSON.parse(event.data);
      if (result.type === "event") {
        if (this.clientSubscriptionCallback)
          this.clientSubscriptionCallback(id, result.data);
      } else if (result.type === "response") {
        if (this.requestMap.has(id)) {
          (_a = this.requestMap.get(id)) == null ? void 0 : _a({ type: "response", result: result.data });
          this.requestMap.delete(id);
        }
      } else if (result.type === "error") {
        const { message, code } = result.data;
        if (this.requestMap.has(id)) {
          (_b = this.requestMap.get(id)) == null ? void 0 : _b({ type: "error", message, code });
          this.requestMap.delete(id);
        }
      } else {
        console.error(`Received event of unknown type '${result.type}'`);
      }
    });
    this.ws.addEventListener("close", (event) => {
      this.reconnect();
    });
  }
  async reconnect(timeoutIndex = 0) {
    let timeout = (timeouts[timeoutIndex] ?? timeouts[timeouts.length - 1]) + (Math.floor(Math.random() * 5e3) + 1);
    setTimeout(() => {
      let ws = new WebSocket(this.url);
      new Promise(function(resolve, reject) {
        ws.addEventListener("open", () => resolve(null));
        ws.addEventListener("close", reject);
      }).then(() => {
        this.ws = ws;
        this.attachEventListeners();
      }).catch((err) => this.reconnect(timeoutIndex++));
    }, timeout);
  }
  async doRequest(operation, key, input, opts) {
    if (this.ws.readyState == 0) {
      let resolve2;
      const promise2 = new Promise((res) => {
        resolve2 = () => res(void 0);
      });
      this.ws.addEventListener("open", resolve2);
      await promise2;
    }
    const id = randomId();
    let resolve;
    const promise = new Promise((res) => {
      resolve = res;
    });
    this.requestMap.set(id, resolve);
    this.ws.send(
      JSON.stringify({
        id,
        method: operation,
        params: {
          path: key,
          input
        }
      })
    );
    const body = await promise;
    if (body.type === "error") {
      const { code, message } = body;
      throw new RSPCError(code, message);
    } else if (body.type === "response") {
      return body.result;
    } else {
      throw new Error(
        `RSPC Websocket doRequest received invalid body type '${body == null ? void 0 : body.type}'`
      );
    }
  }
};
var NoOpTransport = class {
  constructor() {
  }
  async doRequest(operation, key, input) {
    return new Promise(() => {
    });
  }
};

// src/client.ts
function createClient(args) {
  return new Client(args);
}
var Client = class {
  constructor(args) {
    this._rspc_def = void 0;
    this.subscriptionMap = /* @__PURE__ */ new Map();
    this.transport = args.transport;
    this.transport.clientSubscriptionCallback = (id, value) => {
      var _a;
      const func = (_a = this.subscriptionMap) == null ? void 0 : _a.get(id);
      if (func !== void 0)
        func(value);
    };
    this.subscriptionMap = /* @__PURE__ */ new Map();
    this.onError = args.onError;
  }
  async query(keyAndInput) {
    try {
      return await this.transport.doRequest(
        "query",
        keyAndInput[0],
        keyAndInput[1]
      );
    } catch (err) {
      if (this.onError) {
        this.onError(err);
      }
      throw err;
    }
  }
  async mutation(keyAndInput) {
    try {
      return await this.transport.doRequest(
        "mutation",
        keyAndInput[0],
        keyAndInput[1]
      );
    } catch (err) {
      if (this.onError) {
        this.onError(err);
      }
      throw err;
    }
  }
  addSubscription(keyAndInput, opts) {
    var _a;
    try {
      let subscriptionId = randomId();
      let unsubscribed = false;
      const cleanup = () => {
        var _a2;
        (_a2 = this.subscriptionMap) == null ? void 0 : _a2.delete(subscriptionId);
        if (subscriptionId) {
          this.transport.doRequest(
            "subscriptionStop",
            void 0,
            subscriptionId
          );
        }
      };
      this.transport.doRequest("subscription", keyAndInput[0], [
        subscriptionId,
        keyAndInput[1]
      ]);
      if (opts.onStarted)
        opts.onStarted();
      (_a = this.subscriptionMap) == null ? void 0 : _a.set(subscriptionId, opts.onData);
      return () => {
        unsubscribed = true;
        cleanup();
      };
    } catch (err) {
      if (this.onError) {
        this.onError(err);
      }
      return () => {
      };
    }
  }
};

// src/error.ts
var RSPCError = class {
  constructor(code, message) {
    this.code = code;
    this.message = message;
  }
};
export {
  Client,
  FetchTransport,
  NoOpTransport,
  RSPCError,
  WebsocketTransport,
  createClient,
  randomId
};
//# sourceMappingURL=index.mjs.map