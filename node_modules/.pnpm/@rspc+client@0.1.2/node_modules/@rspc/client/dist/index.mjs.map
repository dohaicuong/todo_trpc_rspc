{"version":3,"sources":["../src/transport.ts","../src/client.ts","../src/error.ts"],"sourcesContent":["// TODO: Redo this entire system when links are introduced\n// TODO: Make this file work off Typescript types which are exported from Rust to ensure internal type-safety!\nimport { OperationType, RSPCError } from \".\";\n\n// TODO\nexport interface Transport {\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\n\n  doRequest(operation: OperationType, key: string, input: any): Promise<any>;\n}\n\n// TODO\nexport class FetchTransport implements Transport {\n  private url: string;\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\n\n  constructor(url: string) {\n    this.url = url;\n  }\n\n  async doRequest(\n    operation: OperationType,\n    key: string,\n    input: any\n  ): Promise<any> {\n    if (operation === \"subscription\" || operation === \"subscriptionStop\") {\n      throw new Error(\n        `Subscribing to '${key}' failed as the HTTP transport does not support subscriptions! Maybe try using the websocket transport?`\n      );\n    }\n\n    let method = \"GET\";\n    let body = undefined as any;\n    let headers = new Headers();\n\n    const params = new URLSearchParams();\n    if (operation === \"query\") {\n      if (input !== undefined) {\n        params.append(\"input\", JSON.stringify(input));\n      }\n    } else if (operation === \"mutation\") {\n      method = \"POST\";\n      body = JSON.stringify(input || {});\n      headers.set(\"Content-Type\", \"application/json\");\n    }\n    const paramsStr = params.toString();\n    const resp = await fetch(\n      `${this.url}/${key}${paramsStr.length > 0 ? `?${paramsStr}` : \"\"}`,\n      {\n        method,\n        body,\n        headers,\n      }\n    );\n\n    const respBody = await resp.json();\n    const { type, data } = respBody.result;\n    if (type === \"error\") {\n      const { code, message } = data;\n      throw new RSPCError(code, message);\n    }\n    return data;\n  }\n}\n\nexport const randomId = () => Math.random().toString(36).slice(2);\n\nconst timeouts = [1000, 2000, 5000, 10000]; // In milliseconds\n\nexport class WebsocketTransport implements Transport {\n  private url: string;\n  private ws: WebSocket;\n  private requestMap = new Map<string, (data: any) => void>();\n  clientSubscriptionCallback?: (id: string, value: any) => void;\n\n  constructor(url: string) {\n    this.url = url;\n    this.ws = new WebSocket(url);\n    this.attachEventListeners();\n  }\n\n  attachEventListeners() {\n    this.ws.addEventListener(\"message\", (event) => {\n      const { id, result } = JSON.parse(event.data);\n      if (result.type === \"event\") {\n        if (this.clientSubscriptionCallback)\n          this.clientSubscriptionCallback(id, result.data);\n      } else if (result.type === \"response\") {\n        if (this.requestMap.has(id)) {\n          this.requestMap.get(id)?.({ type: \"response\", result: result.data });\n          this.requestMap.delete(id);\n        }\n      } else if (result.type === \"error\") {\n        const { message, code } = result.data;\n        if (this.requestMap.has(id)) {\n          this.requestMap.get(id)?.({ type: \"error\", message, code });\n          this.requestMap.delete(id);\n        }\n      } else {\n        console.error(`Received event of unknown type '${result.type}'`);\n      }\n    });\n\n    this.ws.addEventListener(\"close\", (event) => {\n      this.reconnect();\n    });\n  }\n\n  async reconnect(timeoutIndex = 0) {\n    let timeout =\n      (timeouts[timeoutIndex] ?? timeouts[timeouts.length - 1]) +\n      (Math.floor(Math.random() * 5000 /* 5 Seconds */) + 1);\n\n    setTimeout(() => {\n      let ws = new WebSocket(this.url);\n      new Promise(function (resolve, reject) {\n        ws.addEventListener(\"open\", () => resolve(null));\n        ws.addEventListener(\"close\", reject);\n      })\n        .then(() => {\n          this.ws = ws;\n          this.attachEventListeners();\n        })\n        .catch((err) => this.reconnect(timeoutIndex++));\n    }, timeout);\n  }\n\n  async doRequest(\n    operation: OperationType,\n    key: string,\n    input: any,\n    opts?: {\n      id?: string;\n    }\n  ): Promise<any> {\n    if (this.ws.readyState == 0) {\n      let resolve: () => void;\n      const promise = new Promise((res) => {\n        resolve = () => res(undefined);\n      });\n      // @ts-ignore\n      this.ws.addEventListener(\"open\", resolve);\n      await promise;\n    }\n\n    const id = randomId();\n    let resolve: (data: any) => void;\n    const promise = new Promise((res) => {\n      resolve = res;\n    });\n\n    // @ts-ignore\n    this.requestMap.set(id, resolve);\n\n    this.ws.send(\n      JSON.stringify({\n        id,\n        method: operation,\n        params: {\n          path: key,\n          input,\n        },\n      })\n    );\n\n    const body = (await promise) as any;\n    if (body.type === \"error\") {\n      const { code, message } = body;\n      throw new RSPCError(code, message);\n    } else if (body.type === \"response\") {\n      return body.result;\n    } else {\n      throw new Error(\n        `RSPC Websocket doRequest received invalid body type '${body?.type}'`\n      );\n    }\n  }\n}\n\n// TODO\nexport class NoOpTransport implements Transport {\n  constructor() {}\n\n  async doRequest(\n    operation: OperationType,\n    key: string,\n    input: string\n  ): Promise<any> {\n    return new Promise(() => {});\n  }\n}\n","// TODO: Redo this entire system when links are introduced\nimport {\n  RSPCError,\n  ProceduresLike,\n  inferQueryResult,\n  ProceduresDef,\n  inferMutationResult,\n  inferProcedures,\n  inferSubscriptionResult,\n  _inferInfiniteQueryProcedureHandlerInput,\n  _inferProcedureHandlerInput,\n} from \".\";\nimport { randomId, Transport } from \"./transport\";\n\n// TODO\nexport interface SubscriptionOptions<TOutput> {\n  onStarted?: () => void;\n  onData: (data: TOutput) => void;\n  onError?: (err: RSPCError) => void;\n}\n\n// TODO\nexport interface ClientArgs {\n  transport: Transport;\n  onError?: (err: RSPCError) => void | Promise<void>;\n}\n\n// TODO\nexport function createClient<TProcedures extends ProceduresLike>(\n  args: ClientArgs\n): Client<inferProcedures<TProcedures>> {\n  return new Client(args);\n}\n\n// TODO\nexport class Client<TProcedures extends ProceduresDef> {\n  public _rspc_def: ProceduresDef = undefined!;\n  private transport: Transport;\n  private subscriptionMap = new Map<string, (data: any) => void>();\n  private onError?: (err: RSPCError) => void | Promise<void>;\n\n  constructor(args: ClientArgs) {\n    this.transport = args.transport;\n    this.transport.clientSubscriptionCallback = (id, value) => {\n      const func = this.subscriptionMap?.get(id);\n      if (func !== undefined) func(value);\n    };\n    this.subscriptionMap = new Map();\n    this.onError = args.onError;\n  }\n\n  async query<K extends TProcedures[\"queries\"][\"key\"] & string>(\n    keyAndInput: [\n      key: K,\n      ...input: _inferProcedureHandlerInput<TProcedures, \"queries\", K>\n    ]\n  ): Promise<inferQueryResult<TProcedures, K>> {\n    try {\n      return await this.transport.doRequest(\n        \"query\",\n        keyAndInput[0],\n        keyAndInput[1]\n      );\n    } catch (err) {\n      if (this.onError) {\n        this.onError(err as RSPCError);\n      }\n      throw err;\n    }\n  }\n\n  async mutation<K extends TProcedures[\"mutations\"][\"key\"] & string>(\n    keyAndInput: [\n      key: K,\n      ...input: _inferProcedureHandlerInput<TProcedures, \"mutations\", K>\n    ]\n  ): Promise<inferMutationResult<TProcedures, K>> {\n    try {\n      return await this.transport.doRequest(\n        \"mutation\",\n        keyAndInput[0],\n        keyAndInput[1]\n      );\n    } catch (err) {\n      if (this.onError) {\n        this.onError(err as RSPCError);\n      }\n      throw err;\n    }\n  }\n\n  // TODO: Redesign this, i'm sure it probably has race conditions but it works for now\n  addSubscription<\n    K extends TProcedures[\"subscriptions\"][\"key\"] & string,\n    TData = inferSubscriptionResult<TProcedures, K>\n  >(\n    keyAndInput: [\n      K,\n      _inferProcedureHandlerInput<TProcedures, \"subscriptions\", K>\n    ],\n    opts: SubscriptionOptions<TData>\n  ): () => void {\n    try {\n      let subscriptionId = randomId();\n      let unsubscribed = false;\n\n      const cleanup = () => {\n        this.subscriptionMap?.delete(subscriptionId);\n        if (subscriptionId) {\n          this.transport.doRequest(\n            \"subscriptionStop\",\n            undefined!,\n            subscriptionId\n          );\n        }\n      };\n\n      this.transport.doRequest(\"subscription\", keyAndInput[0], [\n        subscriptionId,\n        keyAndInput[1],\n      ]);\n\n      if (opts.onStarted) opts.onStarted();\n      this.subscriptionMap?.set(subscriptionId, opts.onData);\n\n      return () => {\n        unsubscribed = true;\n        cleanup();\n      };\n    } catch (err) {\n      if (this.onError) {\n        this.onError(err as RSPCError);\n      }\n\n      return () => {};\n    }\n  }\n}\n","export class RSPCError {\n  code: number;\n  message: string;\n\n  constructor(code: number, message: string) {\n    this.code = code;\n    this.message = message;\n  }\n}\n"],"mappings":"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","names":["resolve","promise","_a"]}