interface Transport {
    clientSubscriptionCallback?: (id: string, key: string, value: any) => void;
    doRequest(operation: OperationType, key: string, input: any): Promise<any>;
}
declare class FetchTransport implements Transport {
    private url;
    clientSubscriptionCallback?: (id: string, key: string, value: any) => void;
    constructor(url: string);
    doRequest(operation: OperationType, key: string, input: any): Promise<any>;
}
declare const randomId: () => string;
declare class WebsocketTransport implements Transport {
    private url;
    private ws;
    private requestMap;
    clientSubscriptionCallback?: (id: string, value: any) => void;
    constructor(url: string);
    attachEventListeners(): void;
    reconnect(timeoutIndex?: number): Promise<void>;
    doRequest(operation: OperationType, key: string, input: any, opts?: {
        id?: string;
    }): Promise<any>;
}
declare class NoOpTransport implements Transport {
    constructor();
    doRequest(operation: OperationType, key: string, input: string): Promise<any>;
}

interface SubscriptionOptions<TOutput> {
    onStarted?: () => void;
    onData: (data: TOutput) => void;
    onError?: (err: RSPCError) => void;
}
interface ClientArgs {
    transport: Transport;
    onError?: (err: RSPCError) => void | Promise<void>;
}
declare function createClient<TProcedures extends ProceduresLike>(args: ClientArgs): Client<inferProcedures<TProcedures>>;
declare class Client<TProcedures extends ProceduresDef> {
    _rspc_def: ProceduresDef;
    private transport;
    private subscriptionMap;
    private onError?;
    constructor(args: ClientArgs);
    query<K extends TProcedures["queries"]["key"] & string>(keyAndInput: [
        key: K,
        ...input: _inferProcedureHandlerInput<TProcedures, "queries", K>
    ]): Promise<inferQueryResult<TProcedures, K>>;
    mutation<K extends TProcedures["mutations"]["key"] & string>(keyAndInput: [
        key: K,
        ...input: _inferProcedureHandlerInput<TProcedures, "mutations", K>
    ]): Promise<inferMutationResult<TProcedures, K>>;
    addSubscription<K extends TProcedures["subscriptions"]["key"] & string, TData = inferSubscriptionResult<TProcedures, K>>(keyAndInput: [
        K,
        _inferProcedureHandlerInput<TProcedures, "subscriptions", K>
    ], opts: SubscriptionOptions<TData>): () => void;
}

declare class RSPCError {
    code: number;
    message: string;
    constructor(code: number, message: string);
}

declare type OperationType = "query" | "mutation" | "subscription" | "subscriptionStop";
declare type ProcedureDef = {
    key: string;
    input: any;
    result: any;
};
/**
 * This type represents the Typescript bindings which are generated from the router by Rust.
 */
declare type ProceduresDef = {
    queries: ProcedureDef;
    mutations: ProcedureDef;
    subscriptions: ProcedureDef;
};
/**
 * A type which allows inferring the type of the bindings
 */
declare type ProceduresLike = {
    _rspc_def: ProceduresDef;
} | ProceduresDef;
/**
 * This is a helper method to infer the type of bindings for this router off other rspc types.
 * The inferred type is what is generated by Rust.
 * @example
 * const rspc = createReactQueryHooks<Operations>();
 * type Bindings = inferBindingsType<typeof rspc>
 */
declare type inferProcedures<TProcedures extends ProceduresLike> = TProcedures extends {
    _rspc_def: ProceduresDef;
} ? TProcedures["_rspc_def"] : TProcedures;
declare type inferProcedureKey<TProcedures extends ProceduresLike, TOperation extends keyof ProceduresDef> = inferProcedures<TProcedures>[TOperation]["key"];
declare type inferProcedure<TProcedures extends ProceduresLike, TOperation extends keyof ProceduresDef, K extends inferProcedureKey<TProcedures, TOperation>> = Extract<inferProcedures<TProcedures>[TOperation], {
    key: K;
}>;
declare type inferProcedureInput<TProcedures extends ProceduresLike, TOperation extends keyof ProceduresDef, K extends inferProcedureKey<TProcedures, TOperation>> = inferProcedure<TProcedures, TOperation, K>["input"];
declare type inferProcedureResult<TProcedures extends ProceduresLike, TOperation extends keyof ProceduresDef, K extends inferProcedureKey<TProcedures, TOperation>> = inferProcedure<TProcedures, TOperation, K>["result"];
declare type _inferProcedureHandlerInput<TProcedures extends ProceduresLike, TOperation extends keyof ProceduresDef, K extends inferProcedures<TProcedures>[TOperation]["key"]> = inferProcedure<TProcedures, TOperation, K>["input"] extends never ? [] : [inferProcedure<TProcedures, TOperation, K>["input"]];
declare type inferQueryInput<TProcedures extends ProceduresLike, T extends inferProcedures<TProcedures>["queries"]["key"][0]> = inferProcedureInput<inferProcedures<TProcedures>, "queries", T>;
declare type inferQueryResult<TProcedures extends ProceduresLike, T extends inferProcedures<TProcedures>["queries"]["key"][0]> = inferProcedureResult<inferProcedures<TProcedures>, "queries", T>;
declare type inferMutationInput<TProcedures extends ProceduresLike, T extends inferProcedures<TProcedures>["mutations"]["key"][0]> = inferProcedureInput<inferProcedures<TProcedures>, "mutations", T>;
declare type inferMutationResult<TProcedures extends ProceduresLike, T extends inferProcedures<TProcedures>["mutations"]["key"][0]> = inferProcedureResult<inferProcedures<TProcedures>, "mutations", T>;
declare type inferSubscriptionInput<TProcedures extends ProceduresLike, T extends inferProcedures<TProcedures>["subscriptions"]["key"][0]> = inferProcedureInput<inferProcedures<TProcedures>, "subscriptions", T>;
declare type inferSubscriptionResult<TProcedures extends ProceduresLike, T extends inferProcedures<TProcedures>["subscriptions"]["key"][0]> = inferProcedureResult<inferProcedures<TProcedures>, "subscriptions", T>;
declare type inferInfiniteQueries<TProcedures extends ProceduresLike> = Exclude<Extract<inferProcedures<TProcedures>["queries"], {
    input: {
        cursor: any;
    };
}>, {
    input: never;
}>;
declare type inferInfiniteQuery<TProcedures extends ProceduresLike, K extends inferInfiniteQueries<TProcedures>["key"]> = Extract<inferInfiniteQueries<TProcedures>, {
    key: K;
}>;
declare type EmptyObjToNever<T> = keyof T extends never ? never : T;
declare type inferInfiniteQueryInput<TProcedures extends ProceduresLike, K extends inferInfiniteQueries<TProcedures>["key"]> = EmptyObjToNever<Omit<inferInfiniteQuery<TProcedures, K>["input"], "cursor">>;
declare type inferInfiniteQueryResult<TProcedures extends ProceduresLike, K extends inferInfiniteQueries<TProcedures>["key"]> = inferInfiniteQuery<TProcedures, K>["result"];
declare type _inferInfiniteQueryProcedureHandlerInput<TProcedures extends ProceduresLike, K extends inferInfiniteQueries<TProcedures>["key"]> = inferInfiniteQueryInput<TProcedures, K> extends never ? [] : [inferInfiniteQueryInput<TProcedures, K>];

export { Client, ClientArgs, FetchTransport, NoOpTransport, OperationType, ProcedureDef, ProceduresDef, ProceduresLike, RSPCError, SubscriptionOptions, Transport, WebsocketTransport, _inferInfiniteQueryProcedureHandlerInput, _inferProcedureHandlerInput, createClient, inferInfiniteQueries, inferInfiniteQuery, inferInfiniteQueryInput, inferInfiniteQueryResult, inferMutationInput, inferMutationResult, inferProcedure, inferProcedureInput, inferProcedureKey, inferProcedureResult, inferProcedures, inferQueryInput, inferQueryResult, inferSubscriptionInput, inferSubscriptionResult, randomId };
