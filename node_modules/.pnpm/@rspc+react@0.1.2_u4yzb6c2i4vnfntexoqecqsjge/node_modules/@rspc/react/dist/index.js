"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }// src/index.tsx




var _react = require('react');






var _reactquery = require('@tanstack/react-query');
var _jsxruntime = require('react/jsx-runtime');
function createReactQueryHooks() {
  const Context = _react.createContext.call(void 0, void 0);
  function useContext() {
    const ctx = _react.useContext.call(void 0, Context);
    if ((ctx == null ? void 0 : ctx.queryClient) === void 0)
      throw new Error(
        "The rspc context has not been set. Ensure you have the <rspc.Provider> component higher up in your component tree."
      );
    return ctx;
  }
  function customQuery(map) {
    return (keyAndInput, opts) => {
      const { rspc, ...rawOpts } = _nullishCoalesce(opts, () => ( {}));
      let client = rspc == null ? void 0 : rspc.client;
      if (!client) {
        client = useContext().client;
      }
      return _reactquery.useQuery.call(void 0, 
        map(keyAndInput),
        async () => {
          return await client.query(map(keyAndInput));
        },
        rawOpts
      );
    };
  }
  function useQuery(keyAndInput, opts) {
    const { rspc, ...rawOpts } = _nullishCoalesce(opts, () => ( {}));
    let client = rspc == null ? void 0 : rspc.client;
    if (!client) {
      client = useContext().client;
    }
    return _reactquery.useQuery.call(void 0, 
      keyAndInput,
      async () => {
        return await client.query(keyAndInput);
      },
      rawOpts
    );
  }
  function useInfiniteQuery(keyAndInput, opts) {
    const { rspc, ...rawOpts } = _nullishCoalesce(opts, () => ( {}));
    let client = rspc == null ? void 0 : rspc.client;
    if (!client) {
      client = useContext().client;
    }
    return _reactquery.useInfiniteQuery.call(void 0, 
      keyAndInput,
      async () => {
        throw new Error("TODO");
      },
      rawOpts
    );
  }
  function customMutation(map) {
    return (key, opts) => {
      const { rspc, ...rawOpts } = _nullishCoalesce(opts, () => ( {}));
      let client = rspc == null ? void 0 : rspc.client;
      if (!client) {
        client = useContext().client;
      }
      return _reactquery.useMutation.call(void 0, async (input) => {
        const actualKey = Array.isArray(key) ? key[0] : key;
        return client.mutation(map([actualKey, input]));
      }, rawOpts);
    };
  }
  function useMutation(key, opts) {
    const { rspc, ...rawOpts } = _nullishCoalesce(opts, () => ( {}));
    let client = rspc == null ? void 0 : rspc.client;
    if (!client) {
      client = useContext().client;
    }
    return _reactquery.useMutation.call(void 0, async (input) => {
      const actualKey = Array.isArray(key) ? key[0] : key;
      return client.mutation([actualKey, input]);
    }, rawOpts);
  }
  function useSubscription(keyAndInput, opts) {
    var _a;
    let client = (_a = opts == null ? void 0 : opts.rspc) == null ? void 0 : _a.client;
    if (!client) {
      client = useContext().client;
    }
    const queryKey = _reactquery.hashQueryKey.call(void 0, keyAndInput);
    const enabled = _nullishCoalesce((opts == null ? void 0 : opts.enabled), () => ( true));
    return _react.useEffect.call(void 0, () => {
      if (!enabled) {
        return;
      }
      let isStopped = false;
      const unsubscribe = client.addSubscription(
        keyAndInput,
        {
          onStarted: () => {
            var _a2;
            if (!isStopped) {
              (_a2 = opts.onStarted) == null ? void 0 : _a2.call(opts);
            }
          },
          onData: (data) => {
            if (!isStopped) {
              opts.onData(data);
            }
          },
          onError: (err) => {
            var _a2;
            if (!isStopped) {
              (_a2 = opts.onError) == null ? void 0 : _a2.call(opts, err);
            }
          }
        }
      );
      return () => {
        isStopped = true;
        unsubscribe();
      };
    }, [queryKey, enabled]);
  }
  return {
    _rspc_def: void 0,
    Provider: ({
      children,
      client,
      queryClient
    }) => /* @__PURE__ */ _jsxruntime.jsx.call(void 0, Context.Provider, {
      value: {
        client,
        queryClient
      },
      children: /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _reactquery.QueryClientProvider, {
        client: queryClient,
        children
      })
    }),
    useContext,
    customQuery,
    useQuery,
    customMutation,
    useMutation,
    useSubscription
  };
}


exports.createReactQueryHooks = createReactQueryHooks;
//# sourceMappingURL=index.js.map