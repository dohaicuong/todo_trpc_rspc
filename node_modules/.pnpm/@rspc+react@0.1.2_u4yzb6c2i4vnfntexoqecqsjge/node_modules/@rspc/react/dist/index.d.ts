import * as react from 'react';
import { ReactElement } from 'react';
import { QueryClient, UseQueryOptions, UseQueryResult, UseMutationOptions, UseMutationResult } from '@tanstack/react-query';
import { ProceduresDef, Client, RSPCError, ProceduresLike, inferProcedures, ProcedureDef, inferQueryResult, _inferProcedureHandlerInput, inferQueryInput, inferMutationResult, inferMutationInput, inferSubscriptionResult } from '@rspc/client';

interface BaseOptions<TProcedures extends ProceduresDef> {
    rspc?: {
        client?: Client<TProcedures>;
    };
}
interface SubscriptionOptions<TOutput> {
    enabled?: boolean;
    onStarted?: () => void;
    onData: (data: TOutput) => void;
    onError?: (err: RSPCError) => void;
}
interface Context<TProcedures extends ProceduresDef> {
    client: Client<TProcedures>;
    queryClient: QueryClient;
}
declare function createReactQueryHooks<TProceduresLike extends ProceduresLike>(): {
    _rspc_def: inferProcedures<TProceduresLike>;
    Provider: ({ children, client, queryClient, }: {
        children?: ReactElement<any, string | react.JSXElementConstructor<any>> | undefined;
        client: Client<inferProcedures<TProceduresLike>>;
        queryClient: QueryClient;
    }) => JSX.Element;
    useContext: () => Context<inferProcedures<TProceduresLike>>;
    customQuery: <TConstrainedProcedures extends ProcedureDef>(map: (key: [key: TConstrainedProcedures["key"], ...input: TConstrainedProcedures["input"]]) => [
        inferProcedures<TProceduresLike>["queries"]["key"] & string,
        inferProcedures<TProceduresLike>["queries"]["input"]
    ]) => <K extends TConstrainedProcedures["key"] & string, TQueryFnData = Extract<TConstrainedProcedures, {
        key: K;
    }>["result"], TData = Extract<TConstrainedProcedures, {
        key: K;
    }>["result"]>(keyAndInput: [key: K, ...input: Extract<TConstrainedProcedures, {
        key: K;
    }>["input"] extends null ? [] : [Extract<TConstrainedProcedures, {
        key: K;
    }>["input"]]], opts?: (Omit<UseQueryOptions<TQueryFnData, RSPCError, TData, [K, Extract<TConstrainedProcedures, {
        key: K;
    }>["input"]]>, "queryKey" | "queryFn"> & BaseOptions<inferProcedures<TProceduresLike>>) | undefined) => UseQueryResult<TData, RSPCError>;
    useQuery: <K_1 extends inferProcedures<TProceduresLike>["queries"]["key"] & string, TQueryFnData_1 = inferQueryResult<inferProcedures<TProceduresLike>, K_1>, TData_1 = inferQueryResult<inferProcedures<TProceduresLike>, K_1>>(keyAndInput: [key: K_1, ...input: _inferProcedureHandlerInput<inferProcedures<TProceduresLike>, "queries", K_1>], opts?: (Omit<UseQueryOptions<TQueryFnData_1, RSPCError, TData_1, [K_1, inferQueryInput<inferProcedures<TProceduresLike>, K_1>]>, "queryKey" | "queryFn"> & BaseOptions<inferProcedures<TProceduresLike>>) | undefined) => UseQueryResult<TData_1, RSPCError>;
    customMutation: <TConstrainedProcedures_1 extends ProcedureDef>(map: (key: [TConstrainedProcedures_1["key"], TConstrainedProcedures_1["input"]]) => [
        inferProcedures<TProceduresLike>["mutations"]["key"] & string,
        inferProcedures<TProceduresLike>["mutations"]["input"]
    ]) => <K_2 extends TConstrainedProcedures_1["key"] & string, TContext = unknown>(key: K_2 | [K_2], opts?: (UseMutationOptions<Extract<TConstrainedProcedures_1, {
        key: K_2;
    }>["result"], RSPCError, Extract<TConstrainedProcedures_1, {
        key: K_2;
    }>["result"] extends never ? undefined : Extract<TConstrainedProcedures_1, {
        key: K_2;
    }>["result"], TContext> & BaseOptions<inferProcedures<TProceduresLike>>) | undefined) => UseMutationResult<Extract<TConstrainedProcedures_1, {
        key: K_2;
    }>["result"], RSPCError, Extract<TConstrainedProcedures_1, {
        key: K_2;
    }>["input"] extends never ? undefined : Extract<TConstrainedProcedures_1, {
        key: K_2;
    }>["input"], TContext>;
    useMutation: <K_3 extends inferProcedures<TProceduresLike>["mutations"]["key"] & string, TContext_1 = unknown>(key: K_3 | [K_3], opts?: (UseMutationOptions<inferMutationResult<inferProcedures<TProceduresLike>, K_3>, RSPCError, inferMutationInput<inferProcedures<TProceduresLike>, K_3> extends never ? undefined : inferMutationInput<inferProcedures<TProceduresLike>, K_3>, TContext_1> & BaseOptions<inferProcedures<TProceduresLike>>) | undefined) => UseMutationResult<inferMutationResult<inferProcedures<TProceduresLike>, K_3>, RSPCError, inferMutationInput<inferProcedures<TProceduresLike>, K_3> extends never ? undefined : inferMutationInput<inferProcedures<TProceduresLike>, K_3>, TContext_1>;
    useSubscription: <K_4 extends inferProcedures<TProceduresLike>["subscriptions"]["key"] & string, TData_2 = inferSubscriptionResult<inferProcedures<TProceduresLike>, K_4>>(keyAndInput: [key: K_4, ...input: _inferProcedureHandlerInput<inferProcedures<TProceduresLike>, "subscriptions", K_4>], opts: SubscriptionOptions<TData_2> & BaseOptions<inferProcedures<TProceduresLike>>) => void;
};

export { BaseOptions, Context, SubscriptionOptions, createReactQueryHooks };
